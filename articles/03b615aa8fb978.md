---
title: "マークルツリーを用いたスマートコントラクト実装の導入"
emoji: "🦁"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["solidity", "typescript", "merkletree", "crypto"]
published: true
---

# 作ったもの
https://github.com/ikmzkRo/WLAQ-mint

# どんな機能？
NFTの発行機能を構築する際、バリデーションを実施するためにホワイトリストを作成します。このホワイトリストに登録された内容通りに発行可能となるように、マークルツリーの技術を活用して制御を加えます。

今回はウォレットアドレスとトークン発行数を指定したホワイトリストで制御されたスマートコントラクトを実装しました。

# 作った動機
業務においてNFTを100件配布しようとした際、オンチェーン上での計算量が過大となり、処理の遅延が発生しました。この問題への解決策として、マークルプルーフ認証が提案され、今回はデモレベルでの実装を行いました。詳細な不具合についてはここでは割愛させていただきます。

# 実装解説
[前回の記事](https://zenn.dev/mizuneko4345/articles/f0b7efe1eedd28)でマークルツリーに関する理論的な理解を深めたところで、今回はその知識を具体的なスマートコントラクトの実装に落とし込んでいきます。

コードの責務は下記の通りです。
| ファイル                  | 説明                                                |
| ------------------------- | --------------------------------------------------- |
| `contracts/WLAQ.sol`      | マークルプルーフ認証を行い、トークン発行を行うスマートコントラクト   |
| `test/WLAQ.ts`            | `contracts/WLAQ.sol`のテストコード                    |
| `utils/data.ts`           | ホワイトアドレスに登録するウォレットアドレスや数量の定義        |
| `utils/interfaces.ts`     | 型定義                                              |
| `utils/merkletree.ts`     | マークルツリーを構築する関数                           |
| `scripts/deploy.ts`       | `contracts/WLAQ.sol`をテストネット上にデプロイするスクリプト    |

## スマートコントラクト
コントラクトデプロイ時に、計算結果のマークルルートを設定します。
```sol
constructor(bytes32 merkleRoot_) ERC721('Zutto Mayonakade Iinoni', 'ZTMY') {
    merkleRoot = merkleRoot_;
}
```

コントラクト内でのMerkleProof認証には、`@openzeppelin/contracts/utils/cryptography/MerkleProof.sol`で提供されている関数を活用します。

バリデーションを正常に通過した場合（つまり、msg.senderとquantityがホワイトリストに登録され、承認された場合）、指定された数量のトークンを指定のアドレスに発行することが可能です。

```sol
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/utils/Counters.sol';
import {MerkleProof} from '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';
...
function mint(uint256 quantity, bytes32[] calldata merkleProof) public {
    bytes32 node = keccak256(abi.encodePacked(msg.sender, quantity));
    require(MerkleProof.verify(merkleProof, merkleRoot, node), 'invalid proof');

    for (uint256 i = 0; i < quantity; i++) {
        uint256 tokenId = _tokenIds.current();
        _mint(msg.sender, tokenId);

        _tokenIds.increment();
    }
}
```

ウォレットアドレスの追加や数量の変更など、運用上の課題に対処するために、新しく計算されたマークルルートを再登録するための関数が導入されています。ただし、この関数は誰でも簡単に更新できてしまうと問題が生じる可能性があります。例えば、悪意を持ったユーザが不正なアドレスをホワイトリストに追加し、それに基づいて計算されたマークルルートを登録するなどの行為が考えられます。これを防ぐために、この関数には`onlyOwner`修飾子が適用され、関数の実行にはオーナーの認証が必要です。
```sol
import "@openzeppelin/contracts/access/Ownable.sol";
...
function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {
    merkleRoot = _merkleRoot;
}
```

現在登録されているマークルルートを返却するための関数が存在します。この関数はオーナーのみが更新できる仕様となっていますが、運用上の確認やテストコードの実行など、情報の取得が必要な際に活用されます。
```sol
function getMerkleRoot() external view returns (bytes32) {
    return merkleRoot;
}
```

https://github.com/ikmzkRo/WLAQ-mint/blob/main/contracts/WLAQ.sol

## テストコード
チェック項目は下記の通りです。
| 項目                  | 説明                                                |
| ------------------------- | --------------------------------------------------- |
|　コントラクトデプロイ      | コントラクトデプロイ時にERC721の名前とシンボルおよびマークルルートが登録されていること。   |
| マークルルートはオーナーのみ更新可能            | 運用上の問題でホワイトリストに変更があった場合、オーナーのみがマークルルートを更新できること。 |
| ホワイトリストに応じたトークン発行       | ホワイトリストに登録されたアドレスと数量に応じた場合のみトークン発行ができること    |
| 残高確認           | ホワイトリストに登録されたアドレスと数量に応じたトークンが発行されたかどうかを確認する       |

https://github.com/ikmzkRo/WLAQ-mint/blob/main/test/WLAQ.ts

## マークルツリー構築用の関数
テストの際に利用する初回デプロイ用と、実際の運用時にホワイトリストを変更できるように設定されています。
```ts
const inputs = flug === 'default'
  ? await makeInputs(usernames, usersQuantity)
  : await makeInputs(usernamesOperation, usersQuantityOperation);
```

ホワイトリストからリーフを生成し、各々をハッシュ化していくことで、マークルツリーを構築します。`getHexRoot()`を使用して、マークルツリーのルートハッシュを取得できます。また、`getHexProof(leaf)`を利用すると、指定されたノードからマークルルートまでの最短経路であるマークルプルーフを取得できます。

```ts
import keccak256 from 'keccak256';
import { MerkleTree } from 'merkletreejs';
...
const leaves = makeLeaves(inputs);
const leavesValue = Object.values(leaves);
const merkleTree = new MerkleTree(leavesValue, keccak256, { sort: true });

const root = merkleTree.getHexRoot();
const proof = merkleTree.getHexProof(leaf);
```

実行結果
:::details yarn run test
```
yarn run v1.22.21
$ hardhat test
Compiled 13 Solidity files successfully


  WLAQ
    Deployment
inputs [
  {
    address: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
    quantity: 1
  },
  {
    address: '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
    quantity: 2
  },
  {
    address: '0x90F79bf6EB2c4f870365E785982E1f101E93b906',
    quantity: 1
  }
]
leaves {
  '0x70997970C51812dc3A010C7d01b50e0d17dc79C8': '0x3f68e79174daf15b50e15833babc8eb7743e730bb9606f922c48e95314c3905c',
  '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC': '0xd0583fe73ce94e513e73539afcb4db4c1ed1834a418c3f0ef2d5cff7c8bb1dee',
  '0x90F79bf6EB2c4f870365E785982E1f101E93b906': '0xb783e75c6c50486379cdb997f72be5bb2b6faae5b2251999cae874bc1b040af7'
}
leavesValue [
  '0x3f68e79174daf15b50e15833babc8eb7743e730bb9606f922c48e95314c3905c',
  '0xd0583fe73ce94e513e73539afcb4db4c1ed1834a418c3f0ef2d5cff7c8bb1dee',
  '0xb783e75c6c50486379cdb997f72be5bb2b6faae5b2251999cae874bc1b040af7'
]
proofs {
  '0x70997970C51812dc3A010C7d01b50e0d17dc79C8': [
    '0xb783e75c6c50486379cdb997f72be5bb2b6faae5b2251999cae874bc1b040af7',
    '0xd0583fe73ce94e513e73539afcb4db4c1ed1834a418c3f0ef2d5cff7c8bb1dee'
  ],
  '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC': [
    '0xf92db5e3e1d6bed45d8e50fad47eddeb89c5453802b5cb6d944df2f3679da55c'
  ],
  '0x90F79bf6EB2c4f870365E785982E1f101E93b906': [
    '0x3f68e79174daf15b50e15833babc8eb7743e730bb9606f922c48e95314c3905c',
    '0xd0583fe73ce94e513e73539afcb4db4c1ed1834a418c3f0ef2d5cff7c8bb1dee'
  ]
}
      ✔ Should return correct name and symbol
    setMerkleRoot check
      ✔ [S] Should set the Merkle Root correctly by Contract deployer
The initial Merkle root at the time of contract deployment undefined
inputs [
  {
    address: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
    quantity: 1
  },
  {
    address: '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
    quantity: 2
  },
  {
    address: '0x90F79bf6EB2c4f870365E785982E1f101E93b906',
    quantity: 3
  },
  {
    address: '0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc',
    quantity: 4
  }
]
leaves {
  '0x70997970C51812dc3A010C7d01b50e0d17dc79C8': '0x3f68e79174daf15b50e15833babc8eb7743e730bb9606f922c48e95314c3905c',
  '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC': '0xd0583fe73ce94e513e73539afcb4db4c1ed1834a418c3f0ef2d5cff7c8bb1dee',
  '0x90F79bf6EB2c4f870365E785982E1f101E93b906': '0x8d1187a2c5d69d9d0f6e6c8baf49c9549b9573585daef9b8634509e0cb8d99ae',
  '0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc': '0x9995999b4cf3fbeb689e3cc965ed87e72ff5cb0c750b5e16639e60ac50a9bdd4'
}
leavesValue [
  '0x3f68e79174daf15b50e15833babc8eb7743e730bb9606f922c48e95314c3905c',
  '0xd0583fe73ce94e513e73539afcb4db4c1ed1834a418c3f0ef2d5cff7c8bb1dee',
  '0x8d1187a2c5d69d9d0f6e6c8baf49c9549b9573585daef9b8634509e0cb8d99ae',
  '0x9995999b4cf3fbeb689e3cc965ed87e72ff5cb0c750b5e16639e60ac50a9bdd4'
]
proofs {
  '0x70997970C51812dc3A010C7d01b50e0d17dc79C8': [
    '0x8d1187a2c5d69d9d0f6e6c8baf49c9549b9573585daef9b8634509e0cb8d99ae',
    '0xec8cfb2be54f182816432181c8e4effe0db09107a1e3459b788f06fd9f3d599e'
  ],
  '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC': [
    '0x9995999b4cf3fbeb689e3cc965ed87e72ff5cb0c750b5e16639e60ac50a9bdd4',
    '0x3c796d3f1fb5030d1d09ecb20dddc5da2479c52d99d12aef90b27fea8d7e6f45'
  ],
  '0x90F79bf6EB2c4f870365E785982E1f101E93b906': [
    '0x3f68e79174daf15b50e15833babc8eb7743e730bb9606f922c48e95314c3905c',
    '0xec8cfb2be54f182816432181c8e4effe0db09107a1e3459b788f06fd9f3d599e'
  ],
  '0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc': [
    '0xd0583fe73ce94e513e73539afcb4db4c1ed1834a418c3f0ef2d5cff7c8bb1dee',
    '0x3c796d3f1fb5030d1d09ecb20dddc5da2479c52d99d12aef90b27fea8d7e6f45'
  ]
}
      ✔ [R] Should not allow setting Merkle Root by Owner
      ✔ [R] Should not allow setting Merkle Root by notOwner
    mint
      ✔ Should allow whitelisted users to mint
      ✔ Should revert when users try to mint over allowed quantity
      ✔ Should revert when non-whitelisted users try to mint


  7 passing (926ms)

Done in 4.38s.npx hardhat verify --network goerli 0x9B97b7bDEFa32b9a26f1Cf27459bcC18281938Ac
```
:::

https://github.com/ikmzkRo/WLAQ-mint/blob/main/utils/merkletree.ts

## コントラクトの Deploy＆Verify
コマンドパターンと`.env`は下記の通りです。
| コマンド                  | 説明                                                |
| ------------------------- | --------------------------------------------------- |
| `npx hardhat run scripts/deploy.ts --network goerli`      | コントラクトをgoerliにデプロイ   |
| `npx hardhat verify --network goerli CA`            | CAにはデプロイした結果のコントラクトアドレスを指定 |

```js: .env
ALCHEMY_API_KEY = "XXXXX"
PRIVATE_KEY = "XXXXX"
ETHERSCAN_API_KEY = "XXXXX"
```

https://github.com/ikmzkRo/WLAQ-mint/blob/main/scripts/deploy.ts

# 課題
## 1. トークン発行後にアドレスと数量の状態を更新できていない
既に指定のアドレスからどれだけトークンが発行されたかという状態を保持する機能が今後必要になる可能性がありますね。

ホワイトリストにウォレットアドレスのみを登録する場合は、以下のような実装となります。トークンを発行した直後、`whitelistClaimed`に`msg.sender`が登録される形です。
```sol
  function whitelistMint(bytes32[] calldata _merkleProof) public payable returns (uint256) {
      require(!whitelistClaimed[msg.sender], "Address already claimed");
      bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
      require(
          MerkleProof.verify(_merkleProof, merkleRoot, leaf),
          "Invalid proof"
      );
      
      _tokenIds.increment();
      uint256 newTokenId = _tokenIds.current();
      _mint(msg.sender, newTokenId);

      whitelistClaimed[msg.sender] = true;
      
      return newTokenId;
  }
```

## 2. マークルルートに対するrequireが不足している
追加のバリデーションとして以下の項目を考慮すると良いでしょう。

- マークルルートが設定されていない
- 既に利用されているマークルルートである

これらの条件を考慮した実装により、より堅牢でセキュアなシステムが構築できます。
```sol
require(root != NULL, "The root is not registered.");
require(!usedMerkleRoots[root], "This root has already used.");
```

# おまけ
マークルツリーを用いたプロジェクトや実装例を貼っておきます。

https://zenn.dev/ryo_takahashi/scraps/ff70f43eb45856#comment-40095f6a46ae37
https://zenn.dev/serinuntius/articles/35c1b6a042174e847766?redirected=1
https://zenn.dev/serinuntius/articles/f56b3dc2871a03?redirected=1
https://zenn.dev/no_plan/articles/581be4ad731a79#merkle-proof%E3%82%92%E7%94%A8%E6%84%8F%E3%81%99%E3%82%8B
https://zenn.dev/0xywzx/articles/bdb6c991f3fc8b

# 感想
- マークルツリー大好き
- 実務でコントラクト書いてレビューで殴られたい
- NFTのシームレスな配布を目の当たりにしたい
- [zkRollup](https://zenn.dev/serinuntius/articles/f56b3dc2871a03?redirected=1#zkrollup%E3%82%92%E6%8E%98%E3%82%8A%E4%B8%8B%E3%81%92%E3%82%8B) の理解に苦しんでいる

# 参考
https://dev.to/peterblockman/understand-merkle-tree-by-making-a-nft-minting-whitelist-1148#validate-data-using-merkle-tree