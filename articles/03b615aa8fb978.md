---
title: "マークルツリーを用いたスマートコントラクト実装"
emoji: "🦁"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["solidity", "merkletree", "crypto"]
published: false
---

# 作ったもの
https://github.com/ikmzkRo/WLAQ-mint

# どんな機能？
NFTの発行機能を構築する際、バリデーションを実施するためにホワイトリストを作成します。このホワイトリストに登録された内容通りに発行可能となるように、マークルツリーの技術を活用して制御を加えます。

今回はウォレットアドレスとトークン発行数を指定したホワイトリストで制御されたスマートコントラクトを実装しました。

# 作った動機
業務においてNFTを100件配布しようとした際、オンチェーン上での計算量が過大となり、処理の遅延が発生しました。この問題への解決策として、マークルプルーフ認証が提案され、今回はデモレベルでの実装を行いました。詳細な不具合についてはここでは割愛させていただきます。

# 実装解説
[前回の記事](https://zenn.dev/mizuneko4345/articles/f0b7efe1eedd28)でマークルツリーに関する理論的な理解を深めたところで、今回はその知識を具体的なスマートコントラクトの実装に落とし込んでいきます。

コードの責務は下記の通りです。
| ファイル                  | 説明                                                |
| ------------------------- | --------------------------------------------------- |
| `contracts/WLAQ.sol`      | マークルプルーフ認証を行い、トークン発行を行うスマートコントラクト   |
| `test/WLAQ.ts`            | `contracts/WLAQ.sol`のテストコード                    |
| `scripts/deploy.ts`       | `contracts/WLAQ.sol`をテストネット上にデプロイするスクリプト    |
| `utils/data.ts`           | ホワイトアドレスに登録するウォレットアドレスや数量の定義        |
| `utils/interfaces.ts`     | 型定義                                              |
| `utils/merkletree.ts`     | マークルツリーを構築する関数                           |

## スマートコントラクト
コントラクトデプロイ時に、計算結果のマークルルートを設定します。
```sol
constructor(bytes32 merkleRoot_) ERC721('Zutto Mayonakade Iinoni', 'ZTMY') {
    merkleRoot = merkleRoot_;
}
```

コントラクト上でのMerkleProof認証には`@openzeppelin/contracts/utils/cryptography/MerkleProof.sol`で提供された関数を利用します。

バリデーションを通過した場合のみ（msg.sender, quantityがホワイトリストに登録されていたと承認された）、指定の数量だけ指定のアドレスにトークンを発行できます。

```sol
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/utils/Counters.sol';
import {MerkleProof} from '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';
...
function mint(uint256 quantity, bytes32[] calldata merkleProof) public {
    bytes32 node = keccak256(abi.encodePacked(msg.sender, quantity));
    require(MerkleProof.verify(merkleProof, merkleRoot, node), 'invalid proof');

    for (uint256 i = 0; i < quantity; i++) {
        uint256 tokenId = _tokenIds.current();
        _mint(msg.sender, tokenId);

        _tokenIds.increment();
    }
}
```

ウォレットアドレスを追加したい、数量を変更したいといった運用上の課題を解決するために、新たに計算したマークルルートを再登録する関数です。もちろん誰でも更新できてしまうといけません、悪意あるユーザが汚れたアドレスを追加したホワイトリストから計算したマークルルートを登録するなどあってはなりませんね。そのために`onlyOwner`を関数のバリデーションとして利用しています。
```sol
import "@openzeppelin/contracts/access/Ownable.sol";
...
function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {
    merkleRoot = _merkleRoot;
}
```

現在登録されているマークルルートを返却する関数です。オーナーのみ更新できる仕様としていますが、運用上の確認やテストコード等で利用するために用意しています。
```sol
function getMerkleRoot() external view returns (bytes32) {
    return merkleRoot;
}
```

https://github.com/ikmzkRo/WLAQ-mint/blob/main/contracts/WLAQ.sol

## テストコード


https://github.com/ikmzkRo/WLAQ-mint/blob/main/test/WLAQ.ts

## マークルツリー構築用の関数


# 課題
ホワイトリストにはアドレスだけでなく数量も含まれているため、既に指定のアドレスからトークンが発行されたかどうかを判定するバリデーション機能は今後必要になる可能性がありますね。

ホワイトリストにウォレットアドレスのみを登録する場合は、以下の実装のように、トークンを発行した直後、whitelistClaimedにmsg.senderが登録されます。
```sol
  function whitelistMint(bytes32[] calldata _merkleProof) public payable returns (uint256) {
      require(!whitelistClaimed[msg.sender], "Address already claimed");
      bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
      require(
          MerkleProof.verify(_merkleProof, merkleRoot, leaf),
          "Invalid proof"
      );
      
      _tokenIds.increment();
      uint256 newTokenId = _tokenIds.current();
      _mint(msg.sender, newTokenId);

      whitelistClaimed[msg.sender] = true;
      
      return newTokenId;
  }
```

# おまけ

- zkrollup
- ZKPMINT
- Uniswap

# 感想
