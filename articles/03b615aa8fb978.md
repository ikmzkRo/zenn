---
title: "マークルツリーを用いたスマートコントラクト実装"
emoji: "🦁"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["solidity", "merkletree", "crypto"]
published: false
---

# 作ったもの
https://github.com/ikmzkRo/WLAQ-mint

# どんな機能？
NFTの発行機能を構築する際、バリデーションを実施するためにホワイトリストを作成します。このホワイトリストに登録された内容通りに発行可能となるように、マークルツリーの技術を活用して制御を加えます。

今回はウォレットアドレスとトークン発行数を指定したホワイトリストで制御されたスマートコントラクトを実装しました。

# 作った動機
業務においてNFTを100件配布しようとした際、オンチェーン上での計算量が過大となり、処理の遅延が発生しました。この問題への解決策として、マークルプルーフ認証が提案され、今回はデモレベルでの実装を行いました。詳細な不具合についてはここでは割愛させていただきます。

# 実装解説
[前回の記事](https://zenn.dev/mizuneko4345/articles/f0b7efe1eedd28)でマークルツリーに関する理論的な理解を深めたところで、今回はその知識を具体的なスマートコントラクトの実装に落とし込んでいきます。

コードの責務は下記の通りです。
| ファイル                  | 説明                                                |
| ------------------------- | --------------------------------------------------- |
| `contracts/WLAQ.sol`      | マークルプルーフ認証を行い、トークン発行を行うスマートコントラクト   |
| `test/WLAQ.ts`            | `contracts/WLAQ.sol`のテストコード                    |
| `utils/data.ts`           | ホワイトアドレスに登録するウォレットアドレスや数量の定義        |
| `utils/interfaces.ts`     | 型定義                                              |
| `utils/merkletree.ts`     | マークルツリーを構築する関数                           |
| `scripts/deploy.ts`       | `contracts/WLAQ.sol`をテストネット上にデプロイするスクリプト    |

## スマートコントラクト
コントラクトデプロイ時に、計算結果のマークルルートを設定します。
```sol
constructor(bytes32 merkleRoot_) ERC721('Zutto Mayonakade Iinoni', 'ZTMY') {
    merkleRoot = merkleRoot_;
}
```

コントラクト上でのMerkleProof認証には`@openzeppelin/contracts/utils/cryptography/MerkleProof.sol`で提供された関数を利用します。

バリデーションを通過した場合のみ（msg.sender, quantityがホワイトリストに登録されていたと承認された）、指定の数量だけ指定のアドレスにトークンを発行できます。

```sol
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/utils/Counters.sol';
import {MerkleProof} from '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';
...
function mint(uint256 quantity, bytes32[] calldata merkleProof) public {
    bytes32 node = keccak256(abi.encodePacked(msg.sender, quantity));
    require(MerkleProof.verify(merkleProof, merkleRoot, node), 'invalid proof');

    for (uint256 i = 0; i < quantity; i++) {
        uint256 tokenId = _tokenIds.current();
        _mint(msg.sender, tokenId);

        _tokenIds.increment();
    }
}
```

ウォレットアドレスを追加したい、数量を変更したいといった運用上の課題を解決するために、新たに計算したマークルルートを再登録する関数です。もちろん誰でも更新できてしまうといけません、悪意あるユーザが汚れたアドレスを追加したホワイトリストから計算したマークルルートを登録するなどあってはなりませんね。そのために`onlyOwner`を関数のバリデーションとして利用しています。
```sol
import "@openzeppelin/contracts/access/Ownable.sol";
...
function setMerkleRoot(bytes32 _merkleRoot) public onlyOwner {
    merkleRoot = _merkleRoot;
}
```

現在登録されているマークルルートを返却する関数です。オーナーのみ更新できる仕様としていますが、運用上の確認やテストコード等で利用するために用意しています。
```sol
function getMerkleRoot() external view returns (bytes32) {
    return merkleRoot;
}
```

https://github.com/ikmzkRo/WLAQ-mint/blob/main/contracts/WLAQ.sol

## テストコード
チェック項目は下記の通りです。
| 項目                  | 説明                                                |
| ------------------------- | --------------------------------------------------- |
|　コントラクトデプロイ      | コントラクトデプロイ時にERC721の名前とシンボルおよびマークルルートが登録されていること。   |
| マークルルートはオーナーのみ更新可能            | 運用上の問題でホワイトリストに変更があった場合、オーナーのみがマークルルートを更新できること。 |
| ホワイトリストに応じたトークン発行       | ホワイトリストに登録されたアドレスと数量に応じた場合のみトークン発行ができること    |
| 残高確認           | ホワイトリストに登録されたアドレスと数量に応じたトークンが発行されたかどうかを確認する       |


https://github.com/ikmzkRo/WLAQ-mint/blob/main/test/WLAQ.ts

## マークルツリー構築用の関数
テストのため初回デプロイ用と運用用でホワイトリストを変更できるようにしています。
```ts
const inputs = flug === 'default'
  ? await makeInputs(usernames, usersQuantity)
  : await makeInputs(usernamesOperation, usersQuantityOperation);
```

ホワイトリストからリーフを作成し、各々ハッシュ化していきマークルツリーを構築します。
`getHexRoot()`でマークルツリーのルートハッシュを取得できます。
`getHexProof(leaf)`でマークルツリーの指定ノードからマークルルートまでの最短経路（マークルプルーフ）を取得できます。

```ts
import keccak256 from 'keccak256';
import { MerkleTree } from 'merkletreejs';
...
const leaves = makeLeaves(inputs);
const leavesValue = Object.values(leaves);
const merkleTree = new MerkleTree(leavesValue, keccak256, { sort: true });

const root = merkleTree.getHexRoot();
const proof = merkleTree.getHexProof(leaf);
```

実行結果
:::details yarn run test
```
yarn run v1.22.21
$ hardhat test
Compiled 13 Solidity files successfully


  WLAQ
    Deployment
inputs [
  {
    address: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
    quantity: 1
  },
  {
    address: '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
    quantity: 2
  },
  {
    address: '0x90F79bf6EB2c4f870365E785982E1f101E93b906',
    quantity: 1
  }
]
leaves {
  '0x70997970C51812dc3A010C7d01b50e0d17dc79C8': '0x3f68e79174daf15b50e15833babc8eb7743e730bb9606f922c48e95314c3905c',
  '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC': '0xd0583fe73ce94e513e73539afcb4db4c1ed1834a418c3f0ef2d5cff7c8bb1dee',
  '0x90F79bf6EB2c4f870365E785982E1f101E93b906': '0xb783e75c6c50486379cdb997f72be5bb2b6faae5b2251999cae874bc1b040af7'
}
leavesValue [
  '0x3f68e79174daf15b50e15833babc8eb7743e730bb9606f922c48e95314c3905c',
  '0xd0583fe73ce94e513e73539afcb4db4c1ed1834a418c3f0ef2d5cff7c8bb1dee',
  '0xb783e75c6c50486379cdb997f72be5bb2b6faae5b2251999cae874bc1b040af7'
]
proofs {
  '0x70997970C51812dc3A010C7d01b50e0d17dc79C8': [
    '0xb783e75c6c50486379cdb997f72be5bb2b6faae5b2251999cae874bc1b040af7',
    '0xd0583fe73ce94e513e73539afcb4db4c1ed1834a418c3f0ef2d5cff7c8bb1dee'
  ],
  '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC': [
    '0xf92db5e3e1d6bed45d8e50fad47eddeb89c5453802b5cb6d944df2f3679da55c'
  ],
  '0x90F79bf6EB2c4f870365E785982E1f101E93b906': [
    '0x3f68e79174daf15b50e15833babc8eb7743e730bb9606f922c48e95314c3905c',
    '0xd0583fe73ce94e513e73539afcb4db4c1ed1834a418c3f0ef2d5cff7c8bb1dee'
  ]
}
      ✔ Should return correct name and symbol
    setMerkleRoot check
      ✔ [S] Should set the Merkle Root correctly by Contract deployer
The initial Merkle root at the time of contract deployment undefined
inputs [
  {
    address: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
    quantity: 1
  },
  {
    address: '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC',
    quantity: 2
  },
  {
    address: '0x90F79bf6EB2c4f870365E785982E1f101E93b906',
    quantity: 3
  },
  {
    address: '0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc',
    quantity: 4
  }
]
leaves {
  '0x70997970C51812dc3A010C7d01b50e0d17dc79C8': '0x3f68e79174daf15b50e15833babc8eb7743e730bb9606f922c48e95314c3905c',
  '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC': '0xd0583fe73ce94e513e73539afcb4db4c1ed1834a418c3f0ef2d5cff7c8bb1dee',
  '0x90F79bf6EB2c4f870365E785982E1f101E93b906': '0x8d1187a2c5d69d9d0f6e6c8baf49c9549b9573585daef9b8634509e0cb8d99ae',
  '0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc': '0x9995999b4cf3fbeb689e3cc965ed87e72ff5cb0c750b5e16639e60ac50a9bdd4'
}
leavesValue [
  '0x3f68e79174daf15b50e15833babc8eb7743e730bb9606f922c48e95314c3905c',
  '0xd0583fe73ce94e513e73539afcb4db4c1ed1834a418c3f0ef2d5cff7c8bb1dee',
  '0x8d1187a2c5d69d9d0f6e6c8baf49c9549b9573585daef9b8634509e0cb8d99ae',
  '0x9995999b4cf3fbeb689e3cc965ed87e72ff5cb0c750b5e16639e60ac50a9bdd4'
]
proofs {
  '0x70997970C51812dc3A010C7d01b50e0d17dc79C8': [
    '0x8d1187a2c5d69d9d0f6e6c8baf49c9549b9573585daef9b8634509e0cb8d99ae',
    '0xec8cfb2be54f182816432181c8e4effe0db09107a1e3459b788f06fd9f3d599e'
  ],
  '0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC': [
    '0x9995999b4cf3fbeb689e3cc965ed87e72ff5cb0c750b5e16639e60ac50a9bdd4',
    '0x3c796d3f1fb5030d1d09ecb20dddc5da2479c52d99d12aef90b27fea8d7e6f45'
  ],
  '0x90F79bf6EB2c4f870365E785982E1f101E93b906': [
    '0x3f68e79174daf15b50e15833babc8eb7743e730bb9606f922c48e95314c3905c',
    '0xec8cfb2be54f182816432181c8e4effe0db09107a1e3459b788f06fd9f3d599e'
  ],
  '0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc': [
    '0xd0583fe73ce94e513e73539afcb4db4c1ed1834a418c3f0ef2d5cff7c8bb1dee',
    '0x3c796d3f1fb5030d1d09ecb20dddc5da2479c52d99d12aef90b27fea8d7e6f45'
  ]
}
      ✔ [R] Should not allow setting Merkle Root by Owner
      ✔ [R] Should not allow setting Merkle Root by notOwner
    mint
      ✔ Should allow whitelisted users to mint
      ✔ Should revert when users try to mint over allowed quantity
      ✔ Should revert when non-whitelisted users try to mint


  7 passing (926ms)

Done in 4.38s.
```
:::

https://github.com/ikmzkRo/WLAQ-mint/blob/main/utils/merkletree.ts

# 課題
ホワイトリストにはアドレスだけでなく数量も含まれているため、既に指定のアドレスからトークンが発行されたかどうかを判定するバリデーション機能は今後必要になる可能性がありますね。

ホワイトリストにウォレットアドレスのみを登録する場合は、以下の実装のように、トークンを発行した直後、whitelistClaimedにmsg.senderが登録されます。
```sol
  function whitelistMint(bytes32[] calldata _merkleProof) public payable returns (uint256) {
      require(!whitelistClaimed[msg.sender], "Address already claimed");
      bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
      require(
          MerkleProof.verify(_merkleProof, merkleRoot, leaf),
          "Invalid proof"
      );
      
      _tokenIds.increment();
      uint256 newTokenId = _tokenIds.current();
      _mint(msg.sender, newTokenId);

      whitelistClaimed[msg.sender] = true;
      
      return newTokenId;
  }
```

初回にマークルルートが設定されていなければrevertするなどもあっても良いですね。
```

```

# おまけ

- zkrollup
- ZKPMINT
- Uniswap

# 感想
