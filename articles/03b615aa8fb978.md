---
title: "マークルツリーを用いたスマートコントラクト実装"
emoji: "🦁"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["solidity", "merkletree", "crypto"]
published: false
---

# 作ったもの
https://github.com/ikmzkRo/WLAQ-mint

# どんな機能？
NFTの発行機能を構築する際、バリデーションを実施するためにホワイトリストを作成します。このホワイトリストに登録された内容通りに発行可能となるように、マークルツリーの技術を活用して制御を加えます。

今回はウォレットアドレスとトークン発行数を指定したホワイトリストで制御されたスマートコントラクトを実装しました。

# 作った動機
業務においてNFTを100件配布しようとした際、オンチェーン上での計算量が過大となり、処理の遅延が発生しました。この問題への解決策として、マークルプルーフ認証が提案され、今回はデモレベルでの実装を行いました。詳細な不具合についてはここでは割愛させていただきます。

# 実装解説
コードの責務は下記の通りです。
| ファイル                  | 説明                                                |
| ------------------------- | --------------------------------------------------- |
| `contracts/WLAQ.sol`      | マークルプルーフ認証を行い、トークン発行を行うスマートコントラクト   |
| `test/WLAQ.ts`            | `contracts/WLAQ.sol`のテストコード                    |
| `scripts/deploy.ts`       | `contracts/WLAQ.sol`をテストネット上にデプロイするスクリプト    |
| `utils/data.ts`           | ホワイトアドレスに登録するウォレットアドレスや数量の定義        |
| `utils/interfaces.ts`     | 型定義                                              |
| `utils/merkletree.ts`     | マークルツリーを構築する関数                           |

## スマートコントラクト
コントラクトデプロイ時に、計算結果のマークルルートを設定します。
```sol
constructor(bytes32 merkleRoot_) ERC721('Zutto Mayonakade Iinoni', 'ZTMY') {
    merkleRoot = merkleRoot_;
}
```

コントラクト上でのMerkleProof認証には`@openzeppelin/contracts/utils/cryptography/MerkleProof.sol`で提供された関数を利用します。




```sol
import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/utils/Counters.sol';
import "@openzeppelin/contracts/access/Ownable.sol";
import {MerkleProof} from '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';
...
function mint(uint256 quantity, bytes32[] calldata merkleProof) public {
    bytes32 node = keccak256(abi.encodePacked(msg.sender, quantity));
    require(MerkleProof.verify(merkleProof, merkleRoot, node), 'invalid proof');

    for (uint256 i = 0; i < quantity; i++) {
        uint256 tokenId = _tokenIds.current();
        _mint(msg.sender, tokenId);

        _tokenIds.increment();
    }
}
```

# 課題
ホワイトリストにはアドレスだけでなく数量も含まれているため、既に指定のアドレスからトークンが発行されたかどうかを判定するバリデーション機能は今後必要になる可能性がありますね。

ホワイトリストにウォレットアドレスのみを登録する場合は、以下の実装のように、トークンを発行した直後、whitelistClaimedにmsg.senderが登録されます。
```sol
  function whitelistMint(bytes32[] calldata _merkleProof) public payable returns (uint256) {
      require(!whitelistClaimed[msg.sender], "Address already claimed");
      bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
      require(
          MerkleProof.verify(_merkleProof, merkleRoot, leaf),
          "Invalid proof"
      );
      
      _tokenIds.increment();
      uint256 newTokenId = _tokenIds.current();
      _mint(msg.sender, newTokenId);

      whitelistClaimed[msg.sender] = true;
      
      return newTokenId;
  }
```

# おまけ

- zkrollup
- ZKPMINT
- Uniswap

# 感想
